library(devtools)
library(roxygen2)
library(rTLS)
library("rTLS", lib.loc="~/R/win-library/3.5")
library(rTLS)
library("rTLS", lib.loc="~/R/win-library/3.5")
#' ###Estimate the dimensionality of a point cloud using a distance of a radius of 0.2.
#' dimen <- cloud_dimensionality(pc_tree[1:100,], method = "distance", radius = 0.2, parallel = FALSE)
#'
#' ###Summary voxels
#' summary_distance(dimen, radius = 0.5)
#'
#' ###Summary voxels and estimated the entropy using bootstrap with 1000 replicates
#' summary_distance(dimen, radius = 0.5, bootstrap = TRUE, R = 1000)
#'
#'@export
summary_distance <- function(data, radius, bootstrap = NULL, R) {
boo <- ifelse(is.null(bootstrap) == TRUE, FALSE, ifelse(bootstrap == FALSE, FALSE, TRUE))
Sphere.radius <- radius
N_spheres <- length(data$n) #Number de voxels
Volumen <- ((4/3)*pi*(radius^3))*N_spheres
Density_mean <- mean(data$n/((4/3)*pi*(radius^3))) #Mean density of points
Density_sd <- sd(data$n/((4/3)*pi*(radius^3))) #Sd of the density of points
H <- shannon(data$n) #H index
data$eq <- 1
Hmax <- shannon(data$eq) #H max
Equitavility <- H/Hmax #Equitavility
Negentropy <- Hmax - H #Negentropy
if(boo == FALSE ) {
frame <- data.frame(Sphere.radius, N_spheres, Volumen, Density_mean, Density_sd, H, Hmax, Equitavility, Negentropy)
} else if(boo == TRUE) {
h_boot <- boot(data$n, shannon_boot, R= R)$t
H_boot_mean <- mean(h_boot) #H index with boot
H_boot_sd <- sd(h_boot)
Equitavility_boot <- H_boot_mean/Hmax #Equitavility based on boot
Negentropy_boot <- Hmax - H_boot_mean #Negentropy based on boot
frame <- data.frame(Sphere.radius, N_spheres, Volumen, Density_mean, Density_sd, H, Hmax, Equitavility, Negentropy, H_boot_mean, H_boot_sd, Equitavility_boot, Negentropy_boot)
}
return(frame)
}
#' ###Estimate the dimensionality of a point cloud using a distance of a radius of 0.2.
#' dimen <- cloud_dimensionality(pc_tree[1:100,], method = "distance", radius = 0.2, parallel = FALSE)
#'
#' ###Summary voxels
#' summary_distance(dimen, radius = 0.5)
#'
#' ###Summary voxels and estimated the entropy using bootstrap with 1000 replicates
#' summary_distance(dimen, radius = 0.5, bootstrap = TRUE, R = 1000)
#'
#'@export
summary_distance <- function(data, radius, bootstrap = NULL, R) {
boo <- ifelse(is.null(bootstrap) == TRUE, FALSE, ifelse(bootstrap == FALSE, FALSE, TRUE))
Sphere.radius <- radius
N_spheres <- length(data$n) #Number de voxels
Volumen <- ((4/3)*pi*(radius^3))*N_spheres
Density_mean <- mean(data$n/((4/3)*pi*(radius^3))) #Mean density of points
Density_sd <- sd(data$n/((4/3)*pi*(radius^3))) #Sd of the density of points
H <- shannon(data$n) #H index
data$eq <- 1
Hmax <- shannon(data$eq) #H max
Equitavility <- H/Hmax #Equitavility
Negentropy <- Hmax - H #Negentropy
if(boo == FALSE ) {
frame <- data.frame(Sphere.radius, N_spheres, Volumen, Density_mean, Density_sd, H, Hmax, Equitavility, Negentropy)
} else if(boo == TRUE) {
h_boot <- boot(data$n, shannon_boot, R= R)$t
H_boot_mean <- mean(h_boot) #H index with boot
H_boot_sd <- sd(h_boot)
Equitavility_boot <- H_boot_mean/Hmax #Equitavility based on boot
Negentropy_boot <- Hmax - H_boot_mean #Negentropy based on boot
frame <- data.frame(Sphere.radius, N_spheres, Volumen, Density_mean, Density_sd, H, Hmax, Equitavility, Negentropy, H_boot_mean, H_boot_sd, Equitavility_boot, Negentropy_boot)
}
return(frame)
}
library(rTLS)
library(rTLS)
library(rTLS)
library(rTLS)
library(rTLS)
data("pc_tree")
parallel <- NULL
fraction <- 0.01
par <- ifelse(is.null(parallel) == TRUE, FALSE, ifelse(parallel == FALSE, FALSE, TRUE))
sizes <- c(0.2, 0.3, 0.4, 0.5)
results <- foreach(i = 1:length(sizes), .inorder = TRUE, .combine= 'rbind', .packages = c("dplyr", "boot"), .export=c("summary_voxels", "voxels", "shannon", "shannon_boot")) %dopar% {
vox <- voxels(cloud[,1:3], voxel.size = sizes[i])
sm <- summary_voxels(vox, voxel.size = sizes[i], bootstrap, R)
}
cloud <- pc_tree
results <- foreach(i = 1:length(sizes), .inorder = TRUE, .combine= 'rbind', .packages = c("dplyr", "boot"), .export=c("summary_voxels", "voxels", "shannon", "shannon_boot")) %dopar% {
vox <- voxels(cloud[,1:3], voxel.size = sizes[i])
sm <- summary_voxels(vox, voxel.size = sizes[i], bootstrap, R)
}
bootstrap = NULL
boo <- ifelse(is.null(bootstrap) == TRUE, FALSE, ifelse(bootstrap == FALSE, FALSE, TRUE))
results <- foreach(i = 1:length(sizes), .inorder = TRUE, .combine= 'rbind', .packages = c("dplyr", "boot"), .export=c("summary_voxels", "voxels", "shannon", "shannon_boot")) %dopar% {
vox <- voxels(cloud[,1:3], voxel.size = sizes[i])
sm <- summary_voxels(vox, voxel.size = sizes[i], boo, R)
}
results
n_points <- round(length(cloud[,1])*fraction, 0)
print(paste("", "Note: ", n_points, " of ", length(cloud[,1]), " points have been used as a sample", sep = ""))
sub <- sample(1:length(cloud[,1]), n_points)
sub <- cloud[sub[order(sub)],]
neig <- neighborhood(sub, cloud, method = "distance", radius = max(sizes), parallel = par)
results <- NA
for(i in 1:length(sizes)) {
new_neig <- sub_neighborhood(neig, method = "distance", new_distance = sizes[i])
dist <- cloud_dimensionality(new_neig)
sm <- summary_distance(dist, radius = sizes[i], bootstrap, R)
results <- rbind(results, sm)
}
shannon <- function(n_points) {
p.i <- n_points/sum(n_points)
H <- (-1) * sum(p.i * log(p.i))
return(H)
}
shannon_boot <- function(n_points, i) {
n_boot <- n_points[i]
p.i <- n_boot/sum(n_boot)
H <- (-1) * sum(p.i * log(p.i))
return(H)
}
n_points[i]
n_points
n_boot
i
n_boot <- n_points[i]
p.i <- n_boot/sum(n_boot)
p.i
H <- (-1) * sum(p.i * log(p.i))
H
return(H)
shannon <- function(n_points) {
p.i <- n_points/sum(n_points)
H <- (-1) * sum(p.i * log(p.i))
return(H)
}
shannon_boot <- function(n_points, i) {
n_boot <- n_points[i]
p.i <- n_boot/sum(n_boot)
H <- (-1) * sum(p.i * log(p.i))
return(H)
}
n_points <- round(length(cloud[,1])*fraction, 0)
print(paste("", "Note: ", n_points, " of ", length(cloud[,1]), " points have been used as a sample", sep = ""))
sub <- sample(1:length(cloud[,1]), n_points)
sub <- cloud[sub[order(sub)],]
neig <- neighborhood(sub, cloud, method = "distance", radius = max(sizes), parallel = par)
results <- NA
for(i in 1:length(sizes)) {
new_neig <- sub_neighborhood(neig, method = "distance", new_distance = sizes[i])
dist <- cloud_dimensionality(new_neig)
sm <- summary_distance(dist, radius = sizes[i], bootstrap, R)
results <- rbind(results, sm)
}
results <- na.exclude(results)
results
plot(results$Sphere.radius, results$Negentropy)
library(rTLS)
data("pc_tree")
n <- neighborhood(pc_tree, method = "distance", radius = 0.2)
library("rTLS", lib.loc="~/R/win-library/3.5")
data("pc_tree")
n <- neighborhood(pc_tree, method = "distance", radius = 0.2)
library(rTLS)
detach("package:rTLS", unload=TRUE)
library("rTLS", lib.loc="~/R/win-library/3.5")
library(rTLS)
library("rTLS", lib.loc="~/R/win-library/3.5")
