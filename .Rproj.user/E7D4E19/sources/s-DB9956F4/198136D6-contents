#' @import dplyr
#'
#' @title An optimal voxel size, radius of a shpere, or k-neigboors.
#'
#' @description Estimate the optimal voxel size, radius of a sphere, or number of k neigboors for a given point cloud based on information theory.
#'
#' @param cloud A \code{matrix} or \code{data.frame} with xyz coordinates in the first three columns.
#' @param method A \code{character} describing the method to use. It most be one of \code{"voxels"}, \code{"radius"}, or \code{"knn"}.
#' @param sizes  A positive \code{numeric} vector to test a range of sizes and select the optimal size. This will be used if \code{method = "voxels"} and if \code{method = "radius"}.
#' @param k A positive \code{integer} vector to test a range of k-neigbors and select the optimal k. This will be used if \code{method = "knn"}.
#' @param fraction A positive \code{numeric} number representing the fraction of points that will be randomly selected as a sample to estimate the optimal size or k. This will be used if \code{method = "radius"} and if \code{method = "knn"}. It most be a value between 0 and 1.#' @param parallel Logical, if \code{TRUE} it use a parallel processing.
#' @param bootstrap A logical vector of length 1. If \code{bootstrap = TRUE}, it compute a bootstrap on the H index calculations.
#' @param R A positive \code{integer} of length 1 indicating the number of bootstrap replicates.
#' @param parallel Logical, if \code{TRUE} it use a parallel processing.
#'
#' @return A \code{data.frame} with the estimated parameters
#' @author J. Antonio Guzman Q. and Ronny Hernandez
#'
#' @examples
#' data("pc_tree")
#'
#' ###Run from an object of class data.frame or matrix
#'
#' range.sizes <- c(0.2, 0.3, 0.4, 0.5)
#'
#' optimal(pc_tree, method = "distance", sizes = range.sizes, fraction = 0.01)
#'
#' ###Run from an object of class neighborhood
#' dist <- neighborhood(pc_tree, method = "distance", radius = 0.2, parallel = FALSE)
#' cloud_dimensionality(dist, method = "distance", radius = 0.2, parallel = FALSE)
#'
#'@export
optimal <- function(cloud, method, sizes, ks, fraction, bootstrap = NULL, R, parallel = NULL) {

  par <- ifelse(is.null(parallel) == TRUE, FALSE, ifelse(parallel == FALSE, FALSE, TRUE))
  boo <- ifelse(is.null(bootstrap) == TRUE, FALSE, ifelse(bootstrap == FALSE, FALSE, TRUE))

  if(method == "voxels") { ###If method is voxels
    results <- foreach(i = 1:length(sizes), .inorder = TRUE, .combine= 'rbind', .packages = c("dplyr", "boot"), .export=c("summary_voxels", "voxels", "shannon", "shannon_boot")) %dopar% {
      vox <- voxels(cloud[,1:3], voxel.size = sizes[i])
      sm <- summary_voxels(vox, voxel.size = sizes[i], boo, R)
    }

  } else if(method == "radius") { ###If method is radius
    n_points <- round(length(cloud[,1])*fraction, 0)
    print(paste("", "Note: ", n_points, " of ", length(cloud[,1]), " points have been used as a sample", sep = ""))
    sub <- sample(1:length(cloud[,1]), n_points)
    sub <- cloud[sub[order(sub)],]

    neig <- neighborhood(sub, cloud, method = "distance", radius = max(sizes), parallel = par)

    results <- NA

    for(i in 1:length(sizes)) {
      new_neig <- sub_neighborhood(neig, method = "distance", new_distance = sizes[i])
      dist <- cloud_dimensionality(new_neig)
      sm <- summary_distance(dist, radius = sizes[i], bootstrap, R)
      results <- rbind(results, sm)
    }

    results <- na.exclude(results)

  } else if(method == "knn") { ###If method is knn
    n_points <- round(length(cloud[,1])*fraction, 0)
    print(paste("", "Note: ", n_points, " of ", length(cloud[,1]), " points have been used as a sample", sep = ""))
    sub <- sample(1:length(cloud[,1]), n_points)
    sub <- cloud[sub[order(sub)],]

    neig <- neighborhood(sub, cloud, method = "knn", k = max(ks), parallel = par)

    results <- NA

    for(i in 1:length(sizes)) {
      new_neig <- sub_neighborhood(neig, method = "knn", new_k = ks[i])
      dist <- cloud_dimensionality(new_neig)
      sm <- summary_knn(dist, k = ks[i], bootstrap, R)
      results <- rbind(results, sm)
    }

    results <- na.exclude(results)

  }
  return(results)
}

