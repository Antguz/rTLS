#' @import dplyr
#'
#' @title An optimal voxel size, radius of a shpere, or k-neigboors.
#'
#' @description Estimate the optimal voxel size, radius of a sphere, or number of k neigboors for a given point cloud based on information theory.
#'
#' @param data A \code{matrix} or \code{data.frame} with xyz coordinates in the first three columns.
#' @param method A \code{character} describing the method to use. It most be one of \code{"voxels"}, \code{"radius"}, or \code{"knn"}.
#' @param sizes  A positive \code{numeric} vector to test a range of sizes and select the optimal size. This will be used if \code{method = "voxels"} and if \code{method = "radius"}.
#' @param k A positive \code{integer} vector to test a range of k-neigbors and select the optimal k. This will be used if \code{method = "knn"}.
#' @param fraction A positive \code{numeric} number representing the fraction of points that will be randomly selected as a sample to estimate the optimal size or k. This will be used if \code{method = "radius"} and if \code{method = "knn"}. It most be a value between 0 and 1.#' @param parallel Logical, if \code{TRUE} it use a parallel processing.
#' @param bootstrap A logical vector of length 1. If \code{bootstrap = TRUE}, it compute a bootstrap on the H index calculations.
#' @param R A positive \code{integer} of length 1 indicating the number of bootstrap replicates.
#' @param parallel Logical, if \code{TRUE} it use a parallel processing.
#'
#' @return A \code{data.frame} with the estimated parameters
#' @author J. Antonio Guzman Q. and Ronny Hernandez
#'
#' @examples
#' data("pc_tree")
#'
#' ###Run from an object of class data.frame or matrix
#' cloud_dimensionality(pc_tree, method = "distance", radius = 0.2, parallel = FALSE)
#'
#' ###Run from an object of class neighborhood
#' dist <- neighborhood(pc_tree, method = "distance", radius = 0.2, parallel = FALSE)
#' cloud_dimensionality(dist, method = "distance", radius = 0.2, parallel = FALSE)
#'
#'@export
optimal <- function(data, method, sizes, k, fraction, bootstrap, R, parallel) {

  par <- ifelse(is.null(parallel) == TRUE, FALSE, ifelse(parallel == FALSE, FALSE, TRUE))

  if(method == "voxels") {
    results <- foreach(i = 1:length(sizes), .inorder = TRUE, .combine= 'rbind', .packages = c("dplyr", "boot"), .export=c("summary_voxels", "voxels", "shannon", "shannon_boot")) %dopar% {
      vox <- voxels(data[,1:3], voxel.size = sizes[i])
      sm <- summary_voxels(vox, voxel.size = sizes[i], bootstrap, R)
    }
  }
  else if(method == "radius") {
    n_points <- round(length(data[,1])*fraction, 0)
    print(paste("", "Note: ", n_points, " of ", length(data[,1]), " points have been used as a sample", sep = ""))
    sub <- sample(1:length(data[,1]), n_points)
    sub <- data[sub[order(sub)],]

    neig <- neighborhood(sub, data, method = "distance", radius = max(sizes), parallel = par)

    results <- NA

    for(i in 1:length(sizes)) {
      new_neig <- sub_neighborhood(neig, method = "distance", new_distance = sizes[i])
      dist <- cloud_dimensionality(new_neig)



      frame <- data.frame(Radius.size = sizes[i],
                          N_spheres = n_points,
                          Volumen = ((4/3 *pi*sizes[i]^3)*n_points),
                          Density_mean = mean(ascale$points/(4/3 *pi*sizes[i]^3)),
                          Density_sd = mean(ascale$points/(4/3 *pi*sizes[i]^3))


    }
  }
  else if(method == "knn") {

  }

  sample(1:20,19)
}

vox_all <- function(cloud, voxel.size, bootstrap, R) {
  frame <- summary_voxels(voxels(pc_tree, voxel.size), voxel.size, bootstrap, R)
  return(frame)
}

vox_all(pc_tree, 0.8, FALSE)
